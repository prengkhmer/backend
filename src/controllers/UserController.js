const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const db = require('../models');
const User = db.User;
const Role = db.Role;
const Permission = db.Permission;

// Verify models are loaded
if (!User) {
  console.error("User model is not loaded properly from models/index.js");
}
if (!Role) {
  console.error("Role model is not loaded properly from models/index.js");
}
const TOKEN_SECRET = process.env.TOKEN_SECRET || "SJDHFKJSDFjshsdhKJ%(*%#74y35";

const getAllUsers = async (req, res) => {
  try {
    const { limit = 10, offset = 0 } = req.query;
    const users = await User.findAll({
      attributes: {
        exclude: ["password"],
      },
      include: [
        {
          model: Role,
          as: "Role", // Matches association alias
          attributes: ["id", "name", "description"], // As you had
        },
      ],
      limit: parseInt(limit), // Pagination
      offset: parseInt(offset),
      //   order: [['createdAt', 'DESC']], // Optional: Sort by newest first
      order: [["createdAt", "ASC"]], // Optional: Sort by newest first
    });

    res.status(200).json({
      message: "All users with roles",
      count: users.length, // Useful metadata
      users, // Renamed for clarity
    });
  } catch (error) {
    console.error("Error fetching all users:", error); // Log for debugging
    res.status(500).json({
      message: "Internal server error", // Standardize
      // error: error.message, // Remove in production; keep for dev
    });
  }
};
// Login method
const login = async (req, res) => {
  try {
    const { username, password } = req.body;
    if (!username || !password) {
      return res
        .status(400)
        .json({ message: "Username and password are required" });
    }

    // Check if models are loaded
    if (!User) {
      console.error("User model is not loaded");
      return res.status(500).json({
        message: "Server configuration error - User model not loaded",
      });
    }
    if (!Role) {
      console.error("Role model is not loaded");
      return res.status(500).json({
        message: "Server configuration error - Role model not loaded",
      });
    }

    const user = await User.findOne({
      where: { username },
      include: [{ model: Role, as: "Role" }], // Now works with association
    });

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    // Compare the provided password with the stored hashed password
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (isValidPassword) {
      // Get user permissions from role - use getPermissions() method
      let permissions = [];

      try {
        if (user.Role && user.Role.id) {
          // Get the role instance
          const role = await Role.findByPk(user.Role.id);

          if (role) {
            // Use Sequelize's getPermissions() method (generated by belongsToMany)
            const rolePermissions = await role.getPermissions();
            permissions = rolePermissions.map((p) => p.name);
          }
        }
      } catch (permError) {
        console.error("Error fetching permissions in login:", permError);
        // If getPermissions fails, try include method as fallback
        try {
          if (user.Role && user.Role.id) {
            const roleWithPermissions = await Role.findByPk(user.Role.id, {
              include: [
                {
                  model: Permission,
                  attributes: ["id", "name", "module", "action"],
                  through: { attributes: [] },
                },
              ],
            });

            if (roleWithPermissions && roleWithPermissions.Permissions) {
              permissions = roleWithPermissions.Permissions.map((p) => p.name);
            }
          }
        } catch (fallbackError) {
          console.error(
            "Fallback permission fetch also failed:",
            fallbackError,
          );
          permissions = [];
        }
      }

      // Generate JWT token
      const token = jwt.sign(
        {
          username: user.username,
          id: user.id,
          role_id: user.Role?.id,
          role: user.Role?.name,
        },
        // TOKEN_SECRET,
        // // { expiresIn: "1h" } // Extended to 24h for better UX
        // { expiresIn: "10m" } // Extended to 24h for better UX
        TOKEN_SECRET,
        {
          // expiresIn: "10m", // JWT expires after 10 minutes
          expiresIn: "24h", // JWT expires after 1h
        },
      );

      res.json({
        success: true,
        token,
        message: "Login successful",
        user: {
          id: user.id,
          name: user.name,
          username: user.username,
          email: user.email,
          role: user.Role?.name || "Unknown",
          role_id: user.Role?.id || null,
          permissions: permissions,
          photo: user.photo,
        },
      });
    } else {
      res.status(401).json({ message: "Invalid password" });
    }
  } catch (err) {
    console.error("Login error:", err);
    res.status(500).json({ message: "Internal server error" });
  }
};

// Admin create user method (bypasses role restrictions)
const createUserByAdmin = async (req, res) => {
  const { name, username, email, password, photo, role_id, status } = req.body;
  try {
    // Check if models are loaded
    if (!User) {
      console.error("User model is not loaded");
      return res.status(500).json({
        message: "Server configuration error - User model not loaded",
      });
    }
    if (!Role) {
      console.error("Role model is not loaded");
      return res.status(500).json({
        message: "Server configuration error - Role model not loaded",
      });
    }

    if (!name || !username || !email || !password) {
      return res.status(400).json({
        message: "Name, username, email, and password are required",
      });
    }

    // Check if user already exists
    const existingUser = await User.findOne({ where: { username } });
    if (existingUser) {
      return res.status(409).json({ message: "Username already exists" });
    }

    // Admin can create users with any role
    let finalRoleId = role_id;

    if (!finalRoleId) {
      // Default to USER role if no role specified
      let userRole = await Role.findOne({ where: { name: "USER" } });
      if (!userRole) {
        userRole = await Role.create({
          name: "USER",
          description: "Normal user with view-only access",
        });
      }
      finalRoleId = userRole.id;
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create user
    const newUser = await User.create({
      name,
      username,
      email,
      password: hashedPassword,
      photo: photo || null,
      role_id: finalRoleId,
      status: status || "ACTIVE", // Default to active
    });

    // Fetch user with role information
    const userWithRole = await User.findByPk(newUser.id, {
      include: [
        {
          model: Role,
          as: "Role",
          attributes: ["id", "name", "description"],
        },
      ],
      attributes: { exclude: ["password"] },
    });

    res.status(201).json({
      success: true,
      message: "User created successfully by admin",
      user: userWithRole,
    });
  } catch (error) {
    console.error("Error creating user by admin:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error",
      error: error.message,
    });
  }
};
const register = async (req, res) => {
  const { name, username, email, password, photo, role_id, status } = req.body;
  try {
    // Check if models are loaded
    if (!User) {
      console.error("User model is not loaded");
      return res.status(500).json({
        message: "Server configuration error - User model not loaded",
      });
    }
    if (!Role) {
      console.error("Role model is not loaded");
      return res.status(500).json({
        message: "Server configuration error - Role model not loaded",
      });
    }

    if (!name || !username || !email || !password) {
      return res.status(400).json({
        message: "Name, username, email, and password are required",
      });
    }

    // Check if user already exists
    const existingUser = await User.findOne({ where: { username } });
    if (existingUser) {
      return res.status(409).json({ message: "Username already exists" });
    }

    // For public registration, always assign USER role
    // Prevent registration with ADMIN or MANAGER roles
    let finalRoleId;

    if (role_id) {
      // Check if trying to register with restricted roles
      const providedRole = await Role.findByPk(role_id);
      if (
        providedRole &&
        (providedRole.name === "ADMIN" || providedRole.name === "MANAGER")
      ) {
        return res.status(403).json({
          message:
            "Cannot register with ADMIN or MANAGER role. USER role will be assigned automatically.",
        });
      }
      // Allow other roles if explicitly provided (for admin-created users)
      finalRoleId = role_id;
    } else {
      // Public registration: Always assign USER role
      let userRole = await Role.findOne({ where: { name: "USER" } });

      // Auto-create USER role if it doesn't exist
      if (!userRole) {
        try {
          userRole = await Role.create({
            name: "USER",
            description: "Normal user with view-only access",
          });

          // Try to assign basic permissions if they exist
          try {
            const basicPermissions = await Permission.findAll({
              where: {
                name: [
                  "view_dashboard",
                  "view_product",
                  "view_category",
                  "view_brand",
                  "view_supplier",
                  "view_sale",
                  "view_sale_item",
                  "view_customer",
                  "view_purchase",
                  "view_purchase_item",
                  "view_notification",
                  "mark_read_notification",
                ],
              },
              limit: 12,
            });

            if (basicPermissions.length > 0) {
              await Promise.all(
                basicPermissions.map(
                  (permission) =>
                    RolePermission.create({
                      role_id: userRole.id,
                      permission_id: permission.id,
                    }).catch(() => null), // Ignore errors if permission doesn't exist
                ),
              );
            }
          } catch (permError) {
            // Permissions might not exist yet, that's okay
            console.log(
              "Note: Permissions not yet initialized. USER role created without permissions.",
            );
          }
        } catch (createError) {
          return res.status(500).json({
            success: false,
            message:
              "Failed to create USER role. Please contact administrator or call /api/setup/init",
            error: createError.message,
          });
        }
      }
      finalRoleId = userRole.id;
    }

    // Hash the password
    const hashedPassword = await bcrypt.hash(password, 10);
    // Create new user with USER role
    const newUser = await User.create({
      name,
      username,
      email,
      password: hashedPassword,
      photo,
      role_id: finalRoleId, // Always USER role for public registration
      status: status || "active", // Default status
    });

    // Include Role and Permissions in response
    const userWithRole = await User.findByPk(newUser.id, {
      include: [
        {
          model: Role,
          as: "Role",
          include: [
            {
              model: Permission,
              attributes: ["id", "name", "module", "action"],
              through: { attributes: [] },
            },
          ],
        },
      ],
      attributes: { exclude: ["password"] },
    });

    const permissions =
      userWithRole?.Role?.Permissions?.map((p) => p.name) || [];

    res.status(201).json({
      success: true,
      message: "User registered successfully",
      user: {
        id: userWithRole.id,
        name: userWithRole.name,
        username: userWithRole.username,
        email: userWithRole.email,
        role: userWithRole.Role?.name || "Unknown",
        role_id: userWithRole.Role?.id || null,
        permissions: permissions,
        status: userWithRole.status,
      },
    });
  } catch (error) {
    console.error("Registration error:", error);
    res.status(500).json({ message: "Internal server error" });
  }
};

// Get user details method
const getUserDetails = async (req, res) => {
  const { id } = req.params; // Fixed syntax
  try {
    if (!id) {
      return res.status(400).json({ message: "ID is required" });
    }

    const user = await User.findByPk(id, {
      include: [{ model: Role, as: "Role" }], // Consistent alias
    });

    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }

    res.json({
      message: "User details by ID",
      user: {
        id: user.id,
        name: user.name,
        username: user.username,
        email: user.email,
        role: user.Role?.name || "Unknown", // Safe access
        // Exclude sensitive fields like password
        photo: user.photo,
        status: user.status,
      },
    });
  } catch (error) {
    console.error("Error fetching user details:", error);
    res.status(500).json({ message: "Internal server error" });
  }
};
const updateUser = async (req, res) => {
  const { id } = req.params;
  const { name, username, email, password, photo, role_id, status } = req.body;
  try {
    const user = await User.findByPk(id);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    // Update fields if provided
    if (name) user.name = name;
    if (username) user.username = username;
    if (email) user.email = email;
    if (password) {
      user.password = await bcrypt.hash(password, 10);
    }
    if (photo) user.photo = photo;
    if (role_id) user.role_id = role_id;
    if (status !== undefined) user.status = status;
    await user.save();
    res.json({ message: "User updated successfully", user });
  } catch (error) {
    console.error("Error updating user:", error);
    res.status(500).json({ message: "Internal server error" });
  }
};

const deleteUser = async (req, res) => {
  const { id } = req.params;
  try {
    const user = await User.findByPk(id);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    await user.destroy();
    res.json({ message: "User deleted successfully" });
  } catch (error) {
    res
      .status(500)
      .json({ message: "Internal server error", error: error.message });
  }
};

// Store OTP temporarily (in production, use Redis or database)
const otpStore = {};

const sendOTP = async (req, res) => {
  try {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({
        message: "Email is required",
        success: false,
      });
    }

    // Check if email exists in database using Sequelize
    const user = await User.findOne({ where: { email } });

    if (!user) {
      return res.status(404).json({
        message: "Email not found",
        success: false,
      });
    }

    // Generate 6-digit OTP
    const otp = Math.floor(100000 + Math.random() * 900000).toString();

    // Store OTP with email (expires in 10 minutes)
    otpStore[email] = {
      otp: otp,
      expiresAt: Date.now() + 10 * 60 * 1000,
    };

    // Send OTP via email
    try {
      const { sendEmail } = require("../services/emailService");

      const subject = "Password Reset OTP - IMS System";
      const html = `
        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
          <h2 style="color: #333;">Password Reset Request</h2>
          <p>Hello,</p>
          <p>You have requested to reset your password for the IMS System. Please use the following OTP to proceed:</p>
          <div style="background-color: #f4f4f4; padding: 20px; text-align: center; margin: 20px 0;">
            <h1 style="color: #007bff; font-size: 32px; margin: 0;">${otp}</h1>
          </div>
          <p><strong>This OTP will expire in 10 minutes.</strong></p>
          <p>If you did not request this password reset, please ignore this email.</p>
          <hr style="margin: 30px 0;">
          <p style="color: #666; font-size: 12px;">This is an automated message from IMS System. Please do not reply to this email.</p>
        </div>
      `;

      await sendEmail(email, subject, html);
      console.log(`✅ OTP email sent successfully to ${email}`);
    } catch (emailError) {
      console.error(`❌ Failed to send OTP email to ${email}:`, emailError);
      // Continue anyway - OTP is still valid for manual entry
    }

    res.json({
      message: "OTP sent to your email successfully",
      success: true,
      // In development, you can return OTP for testing (remove in production)
      // otp: otp
    });
  } catch (err) {
    console.error("Send OTP error:", err);
    res.status(500).json({
      message: "Internal server error",
      success: false,
    });
  }
};

const verifyOtp = async (req, res) => {
  try {
    const { email, otp } = req.body;

    if (!email || !otp) {
      return res.status(400).json({
        message: "Email and OTP are required",
        success: false,
      });
    }

    // Check if OTP exists and is not expired
    if (!otpStore[email]) {
      return res.status(400).json({
        message: "OTP not found or expired",
        success: false,
      });
    }

    if (otpStore[email].expiresAt < Date.now()) {
      delete otpStore[email];
      return res.status(400).json({
        message: "OTP has expired",
        success: false,
      });
    }

    if (otpStore[email].otp !== otp) {
      return res.status(400).json({
        message: "Invalid OTP",
        success: false,
      });
    }

    res.json({
      message: "OTP verified successfully",
      success: true,
    });
  } catch (err) {
    console.error("Verify OTP error:", err);
    res.status(500).json({
      message: "Internal server error",
      success: false,
    });
  }
};

const resetPassword = async (req, res) => {
  try {
    const { email, otp, newPassword } = req.body;

    if (!email || !otp || !newPassword) {
      return res.status(400).json({
        message: "Email, OTP, and new password are required",
        success: false,
      });
    }

    // Verify OTP
    if (!otpStore[email] || otpStore[email].otp !== otp) {
      return res.status(400).json({
        message: "Invalid OTP",
        success: false,
      });
    }

    // Check if OTP is expired
    if (otpStore[email].expiresAt < Date.now()) {
      delete otpStore[email];
      return res.status(400).json({
        message: "OTP has expired",
        success: false,
      });
    }

    // Find user by email
    const user = await User.findOne({ where: { email } });
    if (!user) {
      return res.status(404).json({
        message: "User not found",
        success: false,
      });
    }

    // Hash new password
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // Update password in database using Sequelize
    await user.update({ password: hashedPassword });

    // Clear OTP
    delete otpStore[email];

    res.json({
      message: "Password reset successfully",
      success: true,
    });
  } catch (err) {
    console.error("Reset password error:", err);
    res.status(500).json({
      message: "Internal server error",
      success: false,
    });
  }
};

// Get current logged-in user
const getCurrentUser = async (req, res) => {
  try {
    const userId = req.user.id;

    const user = await User.findByPk(userId, {
      include: [
        {
          model: Role,
          as: "Role",
          include: [
            {
              model: Permission,
              attributes: ["id", "name", "module", "action"],
              through: { attributes: [] },
            },
          ],
        },
      ],
      attributes: { exclude: ["password"] },
    });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    const permissions = user.Role?.Permissions?.map((p) => p.name) || [];

    res.json({
      success: true,
      message: "User retrieved successfully",
      user: {
        id: user.id,
        name: user.name,
        username: user.username,
        email: user.email,
        role: user.Role?.name || "Unknown",
        role_id: user.Role?.id || null,
        permissions: permissions,
        photo: user.photo,
        status: user.status,
      },
    });
  } catch (error) {
    console.error("Error fetching current user:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
};

// Get user permissions
const getUserPermissions = async (req, res) => {
  try {
    const userId = req.user.id;

    const user = await User.findByPk(userId, {
      include: [
        {
          model: Role,
          as: "Role",
          include: [
            {
              model: Permission,
              attributes: ["id", "name", "module", "action"],
              through: { attributes: [] },
            },
          ],
        },
      ],
    });

    if (!user) {
      return res.status(404).json({
        success: false,
        message: "User not found",
      });
    }

    const permissions = user.Role?.Permissions || [];

    res.json({
      success: true,
      message: "Permissions retrieved successfully",
      permissions: permissions.map((p) => ({
        id: p.id,
        name: p.name,
        module: p.module,
        action: p.action,
      })),
      permissionNames: permissions.map((p) => p.name),
    });
  } catch (error) {
    console.error("Error fetching user permissions:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
};

module.exports = {
  getAllUsers,
  login,
  register,
  createUserByAdmin,
  getUserDetails,
  updateUser,
  deleteUser,
  sendOTP,
  verifyOtp,
  resetPassword,
  getCurrentUser,
  getUserPermissions,
};
